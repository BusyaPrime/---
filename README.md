# PDE-LAB: High-Performance 2D Diffusion Solver 

ДИСКЛЕЙМЕР: Проект научного уровня под Кластер, НИУ ИТМО

Жесткий, практически зеро-аллокационный (zero-allocation в горячих циклах), кэш-френдли (cache-friendly) солвер для 2D уравнения теплопроводности и диффузии, написанный чисто на Java 21. Проект заточен под суровые HPC (High-Performance Computing) вычисления на "голом железе" JVM, выжимая максимум из арифметической интенсивности и пропускной способности памяти с помощью примитивных `double[]` массивов. Никаких красивых бизнес-объектов в hot-пасах, только хардкор, матан и голые байты. 

##  Под капотом (Архитектура и Матан)
Солвер решает 2D PDE с переменной диффузией и конвекцией:
$\frac{\partial u}{\partial t} = \nabla \cdot (\kappa \nabla u) - b \cdot \nabla u + f(x, y, t)$

- **Алгоритмы**: Неявные схемы (Crank-Nicolson / Backward Euler), 5-точечный пространственный стенсил с усреднением коэффициентов $\kappa$ по полу-узлам, IMEX-явный расчет направленной (Upwind) конвекции. Плюс адаптивный шаг времени (Adaptive $dt$ via Step-Doubling), чтобы не считать лишнее и не жечь CPU впустую.
- **Итерационные решатели**: PCG (Preconditioned Conjugate Gradient) прокачанный прекондеями **Jacobi** и **SSOR**. Итерации летят как пули, соколиный глаз позавидует (сойдут за O(N)).
- **Data-Oriented Design (DOD)**: Выкинули многомерные массивы на помойку, ибо поинтер-чейзинг — зло. Все ядра жрут плоские 1D массивы. Солвер обсчитывает строго **Внутренние Узлы (Interior Nodes)**, вынося граничные условия за пределы матричных выделений. Никаких переаллокаций в hot-loop'е, наш GC (Garbage Collector) просто курит в сторонке.
- **Интерфейсы Boundary Operators (Граничные условия)**: Родная поддержка Дирихле, Неймана ($\partial u / \partial n$) и Робина. Работают через виртуальные ghost-узлы для идеального сохранения симметрии.
- **Параллелизм на максималках**: Кастомный движок на `CyclicBarrier` и пуле долгоживущих потоков. Авто-чанкинг балансирует лоад (load balancing) по физическим ядрам и множит на ноль фолс-шаринг (false sharing). Никаких модных стримов, только суровые локи и барьеры.

##  Выкатка и Запуск (CLI)

Запилили удобный `PicoCLI` роутер для сборки и прогонов. Забываем про хардкод, всё рулится через аргументы и JSON-документы:

**Сборка жирного джарника (Shadow / Fat JAR):**
```powershell
.\gradlew.bat clean shadowJar verificationTest
```

**Доступные команды в проде:**
```powershell
# Запуск солвера с адаптивным шагом и профилированием JFR (шоб видеть, где память течет)
java -jar build\libs\pdelab-all.jar run --config configs\profile_config.json --adaptive --adaptiveTol 1e-4 --profile jfr

# Генерация Markdown-репорта о математической сходимости схем (пруфаем матан аналитикой)
java -jar build\libs\pdelab-all.jar verify

# Прожарка бенчмарков (JMH тесты SpMV операторов прямо на проде)
java -jar build\libs\pdelab-all.jar bench
```

##  Киллер-фичи (The "Senior++" Hardened Stuff)

- **Pure Interior Mathematics**: Гарантированно симметричная матрица $A$ (SPD condition). Все граничные сдвиги улетают строго в RHS-вектор. Матрицы худеют, считаются быстрее, PCG не отваливается от несимметрии.
- **Fail-Fast Validation & Safe Configs**: `Config.java` ловит кривые сетки ($N \le 0$) и выкидывает `IllegalArgumentException`. Никаких сайлент-фейлов — падаем сразу и с грохотом (fail-fast подход, детка).
- **Адаптивный тайм-степпинг (Adaptive DT)**: Солвер сам режет шаг $dt$, если локальная ошибка пробивает `--adaptiveTol` (экстрополяция Ричардсона в деле).
- **Структурное логирование**: `System.out.println` выпилен под корень вместе с руками джуна, который его написал. Везде **SLF4J + Logback**. Пишем асинхронно, с трейсами в `logs/`, всё по канону.

##  Верификация и CI/CD (Continuous Integration)

Мы пишем матан, поэтому код обязан доказывать свою профпригодность на CI пайплайнах (на слово не верим, верим логам):
1. **Method of Manufactured Solutions (MMS)**: Полное покрытие аналитическими решениями (Homogeneous, Non-Trivial, Variable Kappa). 
2. **`SpatialConvergenceTest`** и **`TemporalConvergenceTest`**: Замороженные тесты, проверяющие, что алгоритм реально выдает $O(h^2)$ и $O(\Delta t^2)$. Упала точность — дропаем пайплайн к чертям, матан не врет.
3. **Регрессионные стейт-тесты (`RegressionTest`)**: Гарантия того, что ваш "маленький безобидный рефакторинг" не сломал флоу JSON артефактов. Фиксированный инпут -> Математически доказуемый идентичный аутпут.

## Артефакты и Телеметрия (Одержимость метриками)
Каждый прогон через `RunCommand` плюет в директорию `artifacts/` железобетонный слепок запуска, чтобы наука была воспроизводимой (и чтобы было чем ткнуть девопсов):
- `metrics.json`: Время, пропускная способность алгоритмов, ошибки L2/Linf, количество итераций сырого PCG.
- `effective_config.json`: Какие на самом деле дефолты применились (например, `threadsEffective`). Чтоб без магии.
- `build_info.json`: Полный аппаратный слепок сервера (Architecture, JVM version, OS, безопасно замаскированный `System.getenv()`).
- `config.json`: Оригинал конфига юзера, чтоб потом не отмазывались, что "оно само".

Всё заточено на максимальный bandwidth памяти по Roofline модели. Гоняйте тесты, деплойте на кластер, и пусть GC плачет от безделья!
